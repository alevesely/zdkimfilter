=pod

=head1 NAME

zfilter_db - zdkimfilter's database test tool

=head1 SYNOPSIS

B<zfilter_db> [I<option> [I<option-arg>... ]...


=head1 DESCRIPTION

This man page describes the database options of zdkimfilter, and then documents
this tool.  Maintaining data by domain name rather than by IP number is what
DKIM is all about, which is why zdkimfilter does this.  Although a database is
not required for basic sign and verify operations, it is needed for DMARC.

B<zfilter_db> connects to the database so as to exercise some of the database
configuration options and queries, as if a message was received and filtered.
Details of the simulated message are set via COMMAND LINE OPTIONS (below).

The database connection is done via OpenDBX.  See the documentation at
http://www.linuxnetworks.de/doc/index.php/OpenDBX for how some options are
mapped to specific backends.


=head1 CONFIGURATION

Database entries in zdkimfilter configuration start with C<db_>.  There are
three groups of them:  (1) Connection, (2) options proper, and (3) queries.
The first group controls the connection itself:

=over

=item B<db_backend>

This is one of the DB engines supported by OpenDBX, which include C<firebird>,
C<mssql>, C<mysql>, C<oracle>, C<pgsql>, C<sqlite>, C<sqlite3>, and C<sybase>.

The name C<test> is recognized internally and not passed to OpenDBX.  In that
case, instead of running a query, the database functions print out a dump of
the allowed variables and their values.  Such dump is appended to file
F<database_dump> in the current directory if the function is linked within
zdkimfilter (used in the testsuite), otherwise it goes to stdout as shown in
EXAMPLES.

=item B<db_host>

Depending on database type and configuration, this can be a host name, an IP
address, a path to a Unix socket, and more.  It is a string passed to
I<odbx_init> as is.

=item B<db_port>

Ditto.

=item B<db_user>, B<db_password>, B<db_database>

These parameters are passed to I<odbx_bind> verbatim.

=item B<db_timeout>

This is a number of seconds.  Not all backends use it.  Defaults to 2.

=back


The second group are the options proper.  These have names starting with
C<db_opt_> and are passed to I<odbx_set_option>, if given, before binding.


=over

=item B<db_opt_tls>

Can be C<A> for always, C<N> for never, or C<T> for try.

=item B<db_opt_multi_statements>

Can be C<Y> or C<N>.

=item B<db_opt_compress>

Can be C<Y> or C<N>.

=item B<db_opt_mode>

Mode of operation.

=item B<db_opt_paged_results>

Number of result records to transfer; 0 means all.

=back


The third groups, queries, are made of items whose names start with C<db_sql_>.
Some queries may or should return a single value; this doc does not distinguish
between queries and statements.

Each query can use a number of variables whose values are collected while
processing a mail message or while preparing a report.  A variable is
identified by a string of the form B<$(>I<variable-name>B<)>.  Missing
variables result in the empty string.

Queries, in turn, can be subdivided into four subgroups:  (1) per-domain
settings, storage of (2) incoming and (3) outgoing messages, and (4) reports.
These subgroups characterize when the relevant queries are run.  In the rest of
this section there is a subsection for each subgroup.

=head2 Per-domain settings

These settings are queried before signature verification of incoming messages.
The first query is new in version 1.5 

=over

=item B<db_sql_whitelisted>

It can use two variables:

=over

=item B<domain>

An authenticated domain name.

=item B<ip>

The IP number of the client.  This variable is given as a hex string, but
with no leading C<0x>.

=back

This query should return an integer.  A value of 1 or higher affects the order
in which DKIM signatures verification is attempted.  A value of 2 or higher
prevents a message from being rejected or dropped due to ADSP.  (A value of 3
or higher will be used in an upcoming version of zdkimfilter.)

Whitelist queries are issued while processing incoming messages.  By contrast,
the other queries are issued after messages have been dealt with.


=head2 Common variables

The other queries, log of incoming and outgoing messages, can use the following
twelve variables:

=over

=item B<ino>, B<mtime>, and B<pid>

These are the values used by Courier to identify a message, the inode, the date
and the process-id.  These variables are given as hex string, but without
the leading C<0x>.

=item B<from>, B<date>, B<message_id>, B<subject>, B<content_type>, and
B<content_encoding>

These are some of the header fields in the message.

=item B<mailing_list>

This flag is 1 if the message has some header fields that are
typical of mailing lists.  Some C<List-*> fields, C<Precedence:list>, and
C<Mailing-List:>.

=item B<envelope_sender>

The bounce address, also known as envelop from or mailfrom.

=item B<ip>

The IP number of the client.  This variable is given as a hex string, but
with no leading C<0x>.

=back

=head2 Log of incoming messages

Incoming messages, after any valid DKIM signature or SPF authentication has
been seen, can be logged to the database by defining some or all of the
queries below.  Besides common variables, the queries in this group can log two
additional sets of variables, one for the message as a whole, and one for each
domain.

=head3 incoming message variables

=over

=item B<message_status>

This is one of the three values: C<accept>, C<reject>, and C<drop>.

=item B<adsp_flags>

A comma separated list of tokens.  One of the three possible values of the
policy, C<unknown>, C<all>, and C<discardable>;  along with C<found>, in case
the (unknown) status was not inferred, and possibly C<fail> and C<whitelisted>.

This, like other comma separated lists, are meant to match SET/ENUM SQL types.

=item B<received_count>

The number of C<Received:> header fields.

=item B<signatures_count>

The number of DKIM signatures.

=back

=head3 incoming domain variables

The second set of variables can also be used by queries in this group, except
for C<db_sql_insert_message>.

=over

=item B<domain>

The domain name.

=item B<reputation>

The integer found via the DKIM-reputation query, if enabled
(see L<zdikimfilter.conf(5)>).

=item B<vbr_mv>

The one of I<trusted_vouchers> that confirmed a VBR claim.

=item B<vbr_response>

The actual string returned by the VBR query.

=item B<auth_type>

A comma separated list of the following tokens:

=over

=item C<author>

For author domain signature.  That is, this domain appears in the From: field.
If B<save_from_anyway> is enabled, the domain is logged with this author domain
flag even if no authentication method validated such claim.

=item C<spf>, C<spf_helo>, C<dkim>, C<dnswl>, and C<vbr>

For the corresponding authentication methods.

=item C<rep> and C<rep_s>

For domains involved in DKIM reputation as subjects and/or signers respectively.

=back

=back

=head3 incoming message queries

=over

=item B<db_sql_insert_message>

This query cannot use the second set of variables, the incoming domain
variables.  That's because multiple domains can be involved in a message
relaying.  The query can return a value that will be made available as a
variable named B<message_ref>.  Since Courier's triplet B<ino>, B<mtime>, and
B<pid> can be used as a unique key to the message database, it is not
imperative that the key of the last inserted message be returned.

If no SQL error occurs, subsequent queries will be called in sequence for each
domain involved.

=item B<db_sql_select_domain>

This query can be used to check whether a domain name exists already.
It can return the key --one row, one column-- which will be made available as
variable B<domain_ref>.

=item B<db_sql_insert_domain>

This query is only issued if the previous query didn't return the key.  It can
return the key too, if multi-statements are allowed.  If it doesn't, a second
call to I<db_sql_select_domain> will be made.

Be wary of double insertions, as multiple filters can be active at the same
time.

=item B<db_sql_update_domain>

This query is issued in case the first call to I<db_sql_select_domain> returned
a B<domain_ref>.  That way, it is possible to update the domain record even if
it existed already.


=item B<db_sql_insert_msg_ref>

This is the last query in the domain loop.  It can be used to select, insert,
and update domain data, leaving the preceding three domain queries undefined.
Or it can use the following two additional variables:

=over

=item B<message_ref>

The value returned by I<db_sql_insert_message>

=item B<domain_ref>

The value returned by either I<db_sql_select_domain> or I<db_sql_insert_domain>.

=back


=back


=head2 Log of outgoing messages

These queries consist of an initial query, a loop for each target domain, and
a final query.  They can use the common variables defined above, and two
additional ones.

=head3 outgoing message variables

=over

=item B<rcpt_count>

The number of envelope recipient that the message is to be sent to.

=item B<domain>

This is either the user domain, in I<db_sql_select_user> and
I<db_sql_check_user>, or one of the domains where the message is destined
(target domains).

=item B<complaint_flag>

A flag that likely identifies the message as a complaint:

=over

=item bit 0 (complaint_flag E<amp> 1)

The envelope sender is empty.

=item bit 1 (complaint_flag E<amp> 2)

The From: field contains "postmaster"

=back

=back

=head3 outgoing message queries

=over

=item B<db_sql_select_user>

This can additionally use B<local_part> and B<domain> is the
authenticated user who sent the message.  It is the first query called for each
message.  It can return two values, that is one row with two columns, that will
be made available as variables B<user_ref> and B<message_ref> to the remaining
queries.


=item B<db_sql_select_target>

This query selects a target B<domain> and returns a B<domain_ref>.  This and
the following queries occur once per target domain; that is, for each of the
domains that appear in one or more of the message's recipients.

=item B<db_sql_insert_target>

This query is called only if no B<domain_ref> was selected by
I<db_sql_select_target>.  It is meant to insert a domain and possibly returns
B<domain_ref> directly.  If it returns nothing, then I<db_sql_select_target> is
called a second time with the same domain.


=item B<db_sql_update_target>

This query is called only if B<domain_ref> was obtained by the first call to
I<db_sql_select_target>; in that case, I<db_sql_insert_target> is not called.


=item B<db_sql_insert_target_ref>

This completes the target loop.  It is called with both B<domain_ref> and
B<message_ref> and provides the many-to-many link between the targeted domain
and the user.


=item B<db_sql_check_user>

This query is called last for outgoing messages.  It can use B<local_part> and
B<domain> as well as B<user_ref> variables to identify the user.  It is meant
to check whether a user's activity is normal or exceedingly high, such as
submitting too many messages for too many recipients, from too many IP
addresses.

If the query returns anything that is not 0 or NULL, and I<blocked_user_list>
is defined, then the filter appends the user-id to that list, quoting the
returned string as a reason.

As the result depends on a query, it can as well consider a field that users
can adjust from a web form in order to temporarily increase their limits.

=back


=head1 COMMAND LINE OPTIONS

The I<option> and I<option-arg> mentioned in the synopsis are command line
arguments.  Any I<option-arg> cannot start with a minus.  They're as follows:

=over

=item B<-v>

Increase verbosity during query processing.  Can be given two or three times to
obtain further details.

=item B<-f> I<config-filename>

Specify the configuration file.

=item B<--config>

Report the C<db_> configuration options only.

=item B<--help>

Print usage and exit.

=item B<--version>

Report package version string and exit.

=item B<--dry-run>

Don't actually run queries, just print them out.  OpenDBX is used normally,
including escaping arguments, but the I<odbx_query> call is skipped.

=item B<--test>

Force the C<test> backend.  OpenDBX is not used at all.  The list of allowed
variables is printed along with their available values, if any.  Using this
option is the same as setting I<db_backend> to C<test>.

=item B<--db-sql-whitelisted> I<domain> ...

Run the query for each domain.  Before displaying the result, the query itself
is displayed, even with no I<-v> option.  An option --that is, an argument
starting with C<->-- marks the end of the domains.

=item B<--set-stats> I<dir> [I<message data>|I<domain>[,I<token>]]

Specify message data.  The I<dir> argument consists of a single character,
either C<i> for incoming or C<o> for outgoing.  The I<option-arg>s
after the it are interpreted as I<message data> if I<domain>[,I<token>] is
given in its own option (see next option).

Up to 12 arguments are accepted for I<message data>:

=over

=item 1.

The IP number for incoming messages, or the authenticated user-id for outgoing
ones.

=item 2.

B<envelope_sender>

=item 3.

B<from>

=item 4.

B<date>

=item 5.

B<message_id>

=item 6.

B<subject>

=item 7.

B<content_type>

=item 8.

B<content_encoding>

=item 9.

B<received_count> for incoming messages, B<rcpt_count> for outgoing ones.


=item 10.

B<signatures_count> for incoming messages, B<complaint_flag> for outgoing ones.

=item 11.

B<mailing_list>


=item 12.

A dot-separated joint of B<ino>, B<mtime>, and B<pid>

=back

Missing arguments are generated at random, so as to insert different records.
A C<@> can be used as a placeholder for a missing argument not at the end.
However, domain names have to be supplied explicitly,
otherwise the call fails with a critical error.

=item B<--set-stats-domain> I<domain>[,I<token>]

Domain names are given one per argument either after this I<option> or after
the previous one.  Each name can be followed, without interleaving spaces, by 
any of C<author>, C<spf>, C<spf_helo>, C<dkim>, C<vbr>, C<rep>, and C<rep_s>,
as seen for incoming messages.  For C<rep> and C<rep_s>, the token can be
followed by a colon (C<:>) and the numeric value of C<reputation>.  For C<vbr>,
the sequence C<vbr[:I<vbr_mv>[:I<vbr_response>]]> is recognized.

A lone C<@> instead of I<domain>[,I<token>] enables the addition of random
tokens to the following domains that have none.

=back

When using the --test or --dry-run options, the calling function won't get
any result from queries.  Hence, some statements are called multiple times.


=head1 EXAMPLES

These examples use MySQL, assuming the database and configuration given in the
tarball files F<odbx_example.sql> and F<odbx_example.conf>.

Check what happens receiving a message:

  $ zfilter_db -f test.conf --set-stats i example.com

Same as above, with a DKIM signature and a VBR vouch:

  $ zfilter_db -f test.conf \
  > --set-stats i example.com,dkim,vbr:dwl.spamhaus.org:all

In each case, the configured db queries are displayed.  Their effect can be
verified using mysql client:

  mysql> SELECT INET_NTOA(CONV(HEX(m.ip),16,10)) AS ip,
      -> FROM_UNIXTIME(m.mtime), d.domain, d.whitelisted AS w, r.auth
      -> FROM msg_ref AS r, message_in AS m, domain AS d
      -> WHERE r.domain=d.id AND r.message_in=m.id AND
      -> FIND_IN_SET('vbr', r.auth);
  +-------------+------------------------+-------------+---+----------+
  | ip          | FROM_UNIXTIME(m.mtime) | domain      | w | auth     |
  +-------------+------------------------+-------------+---+----------+
  | 192.0.2.154 | 2012-11-30 17:22:49    | example.com | 1 | dkim,vbr |
  +-------------+------------------------+-------------+---+----------+
  1 row in set (0.00 sec)


Does the user check function work?  To test it, we simulate an outgoing message
with 8000 recipients.  Since B<rcpt_count> is accepted at position 9, we use
C<@>s placeholders and let the test program assign those values for us:

  $ zfilter_db -f test.conf --set-stats-domain example.org \
  > --set-stats o user@example.com @ @ @ @ @ @ @  8000

The bottom line of the output should report "user check: 0" until the
configured limit is reached.

We can populate the test database as needed, in order to design and test our
procedures and scripts.  But what variables can we use for a given query?
Just ask:

  $ zfilter_db -f test.conf --test \
  > --set-stats i example.com,dkim,vbr:dwl.spamhause.org:all

  Variables allowed for statement db_sql_insert_message:
  ino: 5b5107e6
  mtime: 508c016f
  pid: 7d08
  ip: c000029c
  date: Sat, 27 Oct 2012 17:44:47 +0200
  envelope_sender: bounce.address@example.com
  from: sender@example.com
  subject: Subject of the msg
  message_id: <56154705@example.com>
  content_type: multipart/mixed
  content_encoding: -- not given --
  received_count: 2
  signatures_count: 3
  mailing_list: 1
  adsp_flags: unknown
  message_status: accept


=head1 FILES

=over

=item F<@COURIER_SYSCONF_INSTALL@/filters/zdkimfilter.conf>

Default configuration file.

=back


=head1 AUTHOR


Alessandro Vesely E<lt>vesely@tana.itE<gt>


=head1 SEE ALSO

=over

=item B<RFC 6376>

DomainKeys Identified Mail (DKIM) signatures.

=item B<RFC 6650>

Creation and use of email feedback reports:  An applicability statement for the
Abuse Reporting Format (ARF).

=item B<OpenDBX>

http://www.linuxnetworks.de/doc/index.php/OpenDBX

=item B<odbx_example.sql> and B<odbx_example.conf> in the tarball

There is an example of how to set up database logging as described here,
using MySQL.

=back

=cut

